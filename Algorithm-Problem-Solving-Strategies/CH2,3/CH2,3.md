# CH2 문제 해결 개관

문제 해결 과정

1. 문제를 이해한다.
2. 문제를 익숙한 용어로 재정의한다.(모델링)
3. 어떻게 풀지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.



## 쳬계적인 접근을 위한 질문들

- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 내가 푸는 과정을 수식화 할 수 있을까?
- 문제를 단순화 할 수 없을까?
- 그림으로 그려볼 수 있을까?
- 수식으로 표현 할 수 있을까?
- 문제를 분해할 수 있을까?
- 뒤에서부터 시작해서 문제를 풀 수 있을까?
- 순설를 강제 할 수 있을까?
- 특정 형태의 답만을 고려 할 수 있을까?

## CH3 코딩과 디버깅에 관하여

가장 중요한 것은 읽기 쉬운 코드를 작성 하는 것입니다. 복잡하고 읽기 어려운 코드는 디버깅도 어렵고 한 번에 정확하게 작성하기도 어렵기 때문입니다.



### 3.2 좋은 코드를 짜기 위한 원칙

#### 간결한 코드를 작성하기

프로그래밍 대회에서 코드를 작성 할 때의 첫번째 원칙은 가장 간결한 코드를 작성하라는 것입니다.

#### 적극적으로 코드 재사용하기

간결한 코드를 작성하기 위한 가장 직접적인 방법은 코들르 모듈화 하는 것입니다. 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것이죠.

#### 표준 라이브러리 공부하기

#### 항상 같은 형태로 프로그램을 작성하기

프로그래밍 대회에 참가하다 보면 여러 종류의 코드를 반복저으로 짜게 됩니다. 이분법, 그래프의 너비 우선 탐색 등의 유명한 알고리즘부터, 2차원 평면의 점을표현하는 자료구저, 두 개의 구간이 서로 겹치는지를 확인하는 함수 등이 좋은 예조.

코드를 검증한다는 것은 그렇게 쉬운일은 아니기 때문에 매번 다른 코드를 작성하여 이들을 검증하는 여유를 부리기가 힘들고 이는 피같은 디버깅 시간으로 연결됩니다. 같은 코드를 작성하는 더 좋은 방법에 대해 꾸준히 고민할 필요는 있지만, ***자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있습니다.***

#### 일관적이고 명료한 명명법 사용하기

```C++
bool judge(int y, int x, int cy, int cx, int cr);
bool isInsideCircle(int y, int x, int cy, int cx, int cr);
```

같은 기능을 하는 함수지만 후자가 훨씬 직관적임

#### 모든 자료를 정규화해서 저장하기

좋은 코드의 또 다른 원칙으로 같은 자료를 두 가지 형태로 저장하지 않는 것이있습니다. 예를 들어 유리수를 표현하는 클래스 Fraction을 작성한다고 합니다. 이때 입력받는 유리수를 항상 약분해 기약 분수로 표현하는 것이 좋습니다.

#### 코드와 데이터를 분리하기



### 3.3 자주 하는 실수

같은 실수를 반복하기보다는 실수에서 배우는 것이 좋고, 그보다 더 좋은 것은 남의 실수로부터 배워 유사한 실수를 저지르지 않는 것입니다.

#### 산술 오버플로

#### 배열 범위 밖 원소에 접근

```c++
int array[10], t;
```

이렇게 선언을 하고 array배열과 t가 연속으로 메모리에 할당 되었다면? 이때 실수로 array[10]을 호출하면 엉뚱하게 t가 나옴.

-> 매우 찾기 어려운 버그

***이런 실수를 예방하는 가장 좋은 방법은 당연하게도 배열 크기를 정할 때 게산을 신중히 하는 것.*** 

#### 일관되지 않은 범위 표현 방식 사용하기

배열의 잘못된 위치를 참조하는 오류가 발생하는 가장 큰 원인 중 하나로,  프로그램 내에서 여러 가지의 범위 표현방식을 섞어 쓰는 경우가 있습니다.

대부분의 프로그래밍 언어는 반 열린 구간(half-open interval)을 사용합니다. 반 열린 구간은 첫 번째 값은 집합 안에 포함하고, 다른 하나는 집합 안에 포함하지 않습니다.

->[1,10)  = {1, 2, 3, ... , 9}

- C++ STL에서 반복자(iterator)로 범위를 표현할 때 첫 원소를 가리키는 반복자와 마지막 원소 다음 위치를 가리키는 반복자를 사용합니다. 예를 들어 STL 자료구조에서 모든  원소를 갖는 범위는 *begin(), end()*로 표현하는데, ***begin()은 첫 번째 원소를 가리키지만 end()는 마지막 원소가 아니라 마지막 원소 다음에 있는 가장의 원소를 가리킵니다.*** -> end()는 null 가리킴!

반 열린 구간의 장점

- 첫 번째 값과 마지막 값이 같은 구잔을 이용하면 텅 빈 구간을 쉽게 표현 할 수 있습니다.
- 두 구간이 연속해 있는지를 쉽게 할 수 있습니다. 두 구간[a,b)와 [c,d)가 연속해 있는지를 볼려면 b=c 혹은 a = d인지만 확인하면 됩니다.
- 구간의 크기를 쉽게 알 수 있습니다. ***[a,b)로 표현된 구간에 포함된 자연수의 수는 b - a가 됩니다.***

프로그램 내에서는 한 가지 방법으로만 범위를 표현할 필요가 있습니다. 물론 프로그래밍 언어가 지원하는 범위 표현 방식을 따르는 것이 가장 효율적이지요.

#### Off-by-one 오류

Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 가리킵니다. 예를 들어 100미터인 담장에 10미터 간격으로 울타리 기둥을 세운다고 합시다. 기둥이 몇 개필요 할 까요?

-> 정답은 10개가 아니라 11개입니다.

정수 배열 A[]가 주어질 때A[i]부터 A[j]까지의 평군을 구한다고 합시다. 합을 얼마로 나눠야 할까요?

-> j - i가 아니라 j - i + 1로 나누어야 합니다.

이런 오류를 방지할 수 있는 좋은 방법은 최소 입력이 주어졌을 때 이 코드가 어떻게 동작 할지를 되새겨 보면서 프로그램을 짜는 것입니다.

- 담장의 길이가 0미터라도 기중은 하나 박아햐 하고
- A[1]부터 A[1]까지의 평균을 구할 땐 0이 아니라 1로 나눠야 합니다.

#### 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명에서 낸 오타는 컴파일러가 잡아 주기 때문에 프로그램을 짤때 오타에 대해서는 걱정하지 않는 경우가 많습니다, 하짐나 각종 상수를 잘못 입력해서 문제를 잘 풀어 놓고도 오답 처리 도는 경우를 종종 볼 수 잇습니다.

#### 스택 오버플로

프로그램의 실행 중 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료 되는 것 또한 흔히 하는 실수입니다. 스택 오버플로는 대개 재귀 호출의 깁이가 너무 깊어져서 오는데, 프로그래밍 대회를 공부하면서 재귀 호출을 사용 할 일이 굉장히 많기 때문에 이런 점은 늘 유의하는 것이 좋습니다.

>동적 할당(Dynamic allocation) : 힙(Heap) 영역
>
>지역 변수(Local variable) : 스택(Stack) 영역
>
>전역변수, static 변수(Global variable, static variable) : 데이터(data) 영역

#### 다차원 배열 인덱스 순서 바꿔 쓰기

평소에는 2차원 이상의 다차원 배열을 사용할 일이 많지 않지만, 프로그래밍 대회에서는 심심찮게 4, 5차원 이상의 고차원 배열을 쓰게 됩니다. 이 배열을 이곳 저곳에서 접그나다 보면 한군데쯤에서 인덱스의 순서를 헷갈려서 잘못 쓰는 일이 흔히 있습니다.

#### 잘못된 비교 함수 작성

정수의 집합들을 다루는 프로그램에 정수의 집합을 저장하는 IntegerSet 클래스가 있다고 합시다. 이 프로그램이 하는 일 중하나는 vector< IntegerSet >에 담긴 집합들을 순서대로 처리하는 것인데, 집합 A가 B의 진부분집합이라면 A는 항상 B보다 먼저 처리되어야 합니다.

```c++
//두 정수 집합의 포함관계를 파악하는 잘못된 비교 함수 구현
//Wrong implementaton of comparison function that recognize of subset relationship
bool isProperSubset(const IntegerSet& a, const IntegerSet& b);
bool operator < (const IntegerSet &a, const IntegerSet& b){
    if(isProperSubset(a, b)) return true;
    if(isProperSubset(b,a))) return false;
    
    return false;
}
//Coding convetion of C++ func(des, src)
//Input : {1},{3, 4},{2},{3}
//Output : {1},{3, 4},{2},{3} -> WRONG!!
```

***C++ 표준 라이브러리가 예상하는 일관된 답을 이 코드가 반환하지 않음***

"<" 연산자의 성질

1. a < a는 항상 거짓.
2. a<b가 참이면 b<a는 거짓
3. a<b가 참이고 b<c가 참이면 a<c
4. ***a<b와 b<a 모두 거짓이면 a와 b는 같은 값으로 간주함*** 

위 코드에 의하면

```C++
{1}, {2}, {2, 3}
{2} < {2,3} //이것만 참
{1} < {2} : false;
{1} < {2, 3} : false;
//성질 4에 의하여 {1} == {2}, {1} == {2,3} 이라고 생각함.    
```

***이 성질을 만족시키는 비교 함수를 작성하기 위한 한가지 방법은 a와 b가 완전히 같은 경우를 제외하고는 어느 때도 두 집합이 같다고 판단하지 않는 것***

-> 이를 위해서는 우리가 원하는 조건(포함관계)이 성립하지 않는 두 집합에 대해서도 어떤 별도의 순서를 정해줘야 함

이 별도의 순서는 우리가 원래 정하려 했던 순서와 모순이어서는 안 됩니다. 예를 들어 포함관계가 성립하지 않는 두 집합의 경우 사전순으로 먼저 오는 쪽이 앞에 오기로 랬다고 하지요. 그러나 a = {3}, b = {1, 3}, c = {2}라고 하면

a는 b앞에 와야하고 b는 c앞에 와야하고 c는 a앞에 와야합니다.

-> 세집합의 순서가 명확히 정의 되자 않는다는 문제점이 있음: 사전순서가 포함 관게와 서로 모순되기 때문에

포함관계와 서로 모순되지 않는 ***한가지 방법은 a와 b의 크기를 이용해 비교하는 것. a와 b의 크기가 같을 때에만 사전순으로 비교.***

```c++
//Correct version
bool operator < (const IntegerSet& a, const IntegerSet& b) {
    if(isProperSubset(a, b)) return true;
    if(isProperSubset(b, a)) return false;
    //a와 b의 크기가 다르다면 작은 쪽이 앞에 와야 함.
    if(a,size() != b,size()) return a.size() < b.size();
    /*
    EX : {2}, {1} -> 사전순으로 반환 하면 {1}, {2}
    EX : {1, 3}, {2}
    잘못된 버전 : {1, 3}, {2} -> {2}, {1,3} 이 되어야 함.
    따라서 size 적은게 앞에 오도록 함
    */
    
    //사전순으로 반환
    return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());    
}

/*
	lexicographical_compare -> return true or false
	returen if the range [first1, last1) compares lexicographically
	less than the range [first2, last2)
*/
```

***사전순 비교는 set< Integer > 처럼 크기가 같지만 서로 다른 집합들을 구분해야 할 때 쓰임***



#### 최소, 최대 예외 잘못 다루기

코드를 짤 때 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작 할지를 생각해 보면 오류를 잡을 수 있는 경우가 꽤 있습니다.

```c++
//자연수를 소수인지 판정하는 함수
bool isPrime(int n){
    if(n % 2== 0) return false;
    for(int i = 2; i < n; ++i){
        if(n % i == 0)
            return false;
        return true;
    }
}
//Error: 2는 소수임(2 is prime number)
```

```c++
bool isPrime(int n){
    if(n == 2) return true;
    if(n % 2 == 0) return false;
    for(int i = 2; i < n; ++i){
        if(n % i == 0)
            return false;
        return true;
    }
}
//If argument n is 1? -> error
//1 is not prime number
```

이런 예외를 잘 처리 할 필요가 있다!

#### 연산자 우선순위 잘못 쓰기

```c++
if(b & 1 == 0){
    //Error!
    //==는 &보다 우선순위가 높음
}    
```

#### 너무 느린 입출력 방식 선택

C++에서는 *gets()*를 이용해 모든 입력을 문자열 하나로 읽어드린 뒤 파싱 할 수도 있고, cin 등의 고수준 입력 방식을 사용할 수 도 있음.

***-> 고수준 입출력 방식 이용하면 코드는 간단해지지만, 이에 따른 속도 저하 역시 큼***

#### 변수 초기화 문제

흔한 실수 : 사용한 전역 변수 값을 초기화 하지 않고 그대로 사용하는 것.



### 3.4 디버깅과 테스팅

- 재귀호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거로 디버깅 하기에 적당하지 않음

처음부터 디버깅 하기 쉽게 코드를 짜자!

디버거 대신 사용하기 좋은 방법

- 작은 입력에 대해 제대로 실행되나 확인
- 단정문(assertion) 사용 : 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
- 프로그램의 계산 중간 결과를 출력함.

런타임 오류를 내는 경우는 디버깅을 사용하기 좋은 예

#### 테스트에 대하여

가장 작은 입력과 가장 큰 입력을 만들어서 넣어 보고 시간 안에 실행되는지, 답은 잘 나오는지 테스트 해보는 것이 좋음.

프로그램 테스트에 유용한 기법 ***스캐폴딩(scaffolding)***

- 코드를 계산 할 때 뼈대를 잡기 위해 임시로 사용하는 코드

```c++
//Scaffolding code for testing sorting function
void mySort(vector<int>& array);
string toString(const vector<int>& array);
int main(){
    while(true){
        int n = rand() & 100 + 1;
        vector<int> input(n);
        for(int i = 0; i < n; ++i){
            input[i] = rand();
        }
        vector<int> mySorted = input;
        mySort(mySorted);
        vector<int> reference = input;
        sort(reference.begin(), reference.end());
        if(mySorted != reference){
            cout << /*...*/ << endl;
        }
    }
}
```

여기서는 표준 라이브러리의 코드와 비교했지만, 실제로는 비교할 대상이 없는 경우가 많음. 이럴 경우에 작은 입력에서만 동작하는 더 느리지만 단순한 알고리즘을 사용해 답안을 검증하면 됨.

-> 스캐폴딩 만드는데 시간 더 걸릴수도 있으니 꼭 필요한 경우에만 사용하자!



### 3.5 변수 범위의 이해

#### 산술 오버플로

##### 너무 큰 결과

##### 너무 큰 중간값

##### 너무 큰 '무한대' 값

예를 들어 최단 경로 탐색에서 경로가 아예 없는 경우 -> 이 값에 대한 예외 처리를 따로 해 줘야 함.

- 987,654,321 추천! : $2^{30}$에 가까운 매우 큰 값이면서 서로 더해지더라도 32 비트 부호 있는 정수에 오버플로를 내지 않음.

##### 오버플로 피해가기

- 가장 간단한 방법 : 더 큰 자료형을 사용
- 오버플로가 나지 않도록 연산의 순서를 바꿈(교환법칙, 분배법칙 등...)

##### 자료형의 프로모션

사칙연산이나 대소 비교 등의 이항 연산자들은 두 개의 피연산자를 받습니다. ***만약 피연자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들은 대개 이들을 같은 자료형으로 변환해서 계산하는데, 이를 프로모션이라고 합니다.***

C++에서

1. 한쪽은 정수형, 한쪽은 실수형 -> 정수형이 실수형으로
2. 양쪽 다 정수형 혹은 실수형 -> 보다 넓은 범위 같는걸로
3. 양쪽 다 int형보다 작은 정수형 : int형으로
4. 부호 없는 정수형과 부호있는 정수형 : 부호 없는 정수형으로

```c++
unsigned char a = 17;
short b = -18;
int c = 2;
unsigned int d = 0;
cout << (a + b) * c + d << endl;
//Expect output : -2
//Output : 4294987294 -> WRONG!
//last overflow in "+ operator" -> d is unsigend but last result before + is signed value
```

```c++
vectonr<int> a;
a.size() - 1;
//.size()는 항상 unsigned size_t 반환
//-> 비어있는 벡터의 사이즈에 -1 하면 sigined 가 되면 서 오버플로 발생!
```



### 3.6 실수 자료형의 이해

#### 실수 연산의 어려움

#### 실수와 근사 값

모든것이 셀 수 있고 단위가 정해져 있는 정수들과는 달리 실수를 다루게 되면 일상 생활에서도 무한의 세계로 날아가 버리게 됩니다. ***컴퓨터의 메모리는 항상 유한하고, 이 모든 값들을 모두 정확하게 담을 수는 없으니 어떨수 없이 적절히 비슷한 값을 사용하는 것으로 만족해야 합니다.***

근사 값으로 연산한 결과는 수학적으로 정확하지 않을 수 있기 때문에 실수는 훨씬 다루기 까다롭습니다.

#### IEEE 754 표준

- 이진수로 실수를 표기
- 부동소수점 기법
- 무한대, 비정규수, NaN 등의 특수한 값이 존재

##### 실수의 이진법 표기

##### 부동 소수점 표기

32비트의 공간을 이용해 실수를 이진법으로 표기한다고 합시다. 이 때 고민되는 것은 사용 가능한 비트들을 정수부와 소수부에 어떻게 배분 할 것인가?

- 32비트 중 첫 16비트는 정수부, 뒤 16 비트는 소수부로 사용

이 방식은 이해하기 쉽지만 모두를 만족시키는 분할이 존재하지 않음.

- 정수부에 너무 많은 비트 사용해 버리면 소수부의 정확도가 떨어짐
- 소수부에 너무 많은 비트를 배정하면 큰 수를 표현 할 수 없음

이 문제를 해결하기 위해  IEEE 754를 포함한 대부분의 실수 표준에서는 소수점을 옮길 수 있도록 함.

-> 어떤 형태의 숫자건 소수점을 적절히 옮겨서 소수점 위에 한 자리만 남도록 한 뒤 최상위 비트에서부터 표현 할 수 있는 만큼 표시하고 나머지는 반올림 처리하는 것.

소수점을 몇칸이나 옮겼는지를 기록해두면 원래 값을 쉽게 재구성해낼수 있음.

###### Bticoin money handling

```C++
//money handling of Bitcoin 
int64_t JSONtoAmount(double value) {
    return (int64_t)(value * 1e8 + (value < 0.0 ? -.5 : .5));
}
//don't use float for precision
//Result of float can be different depend on compiler, OS, ETC...
```

부동 소수점 구성

- 부호 비트(sign bit)
- 지수(exponent)
- 가수(mantissa)

#### 실수 비교하기

이진법으로 표현 할 수 없는 형태의 실수는 정환한 값이 아니라 근사 값으로 저장되는데, 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져오는것

```c++
1.000000 == 1.00000000000001;
//return false
fabs(a, b) < 1e-10;
//fabs : return abs of difference
//But it is not perfect too
```

##### 비교할 실수의 크기들에 비례한 오차 한도를 정한다.

##### 상대 오차를 이용한다.

Example

$relativeError(a, b) = {\vert{a - b}\vert\over {max(\vert{a}\vert,\vert{b}\vert)}}$

이렇게 계산한 두 수의 상대 오차가 일정 범위 이하면 같은 수로 판정하도록 합시다. 그러면 실질적인 오차 허용 범위는 a와 b가 커지면 커질수록 더 커짐.

-> 이것도 완벽하지는 않음. 오차가 누적 될 수 있음.

#### 정확한 사칙연산

실수 변수라고 해서 그 값이 항상 정확하지 않은 것은 아님.

#### 가장 좋은 방법은 실수연산을 아예 하지 않는 것

- [Bitcoin money handling](######bticoin-money-handling)
- 곱셈과 나눗셈의 순서를 바꿈
- 양변 제곱
- 실수 좌표를 써야하는 기하 문제에서도 좌표계를 가로 세로로 정수배 늘리면 정수만을 이용해 해결 가능





