# 알고리즘의 정당성 증명

## 5.1 도입

### 알고리즘의 정당성 증명

해결해야 할 문제가 간단할 때는 직관적으로 알고리즘을 설계할 수 있지만, 문제가 복잡해지면 이 알고리즘이 과연 문제를 제대로 해결하는지를 파악하기 까다로움.

알고리즘의 증명을 공부해야 하는 가장 큰 이유는 많은 경우 증명이 알고리즘을 유도하는 데 겨정적인 통찰을 담고 있기 때문.

## 5.2 수학적 귀납법과 반복문 불변식

수학적 귀납법

- 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
- 한 도미노가 쓰러지면 다음 도미노 역시 바로 쓰러진다.

***수학적 귀납법은 이와 같이 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용***

수학적 귀납법은 크게 세 단계로 나뉨

1. 단계 나누기
2. 첫 단계 증명
3. 귀납 증명

### 반복문 불변식

귀납법은 알고리즘의 정당성을 증명 할 때 가장 유용하게 사용되는 기법임. 

-> 대부분의 알고리즘은 어떠한 형태로든 반복적인 요소를 가지고 있기 때문.

귀납법을 이용해 알고리즘의 정당성을 증명 할 때는 반복문 불변식(loop invariant)라는 개념이 유용하게 사용 됨.

- 반복문 불변식이란 반목문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 있는지를 명시한느 조건
- 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 함.

### 이진 탐색과 반복문 불변식

```C++
//Binary search
int binarySearch(const vector<int>& A, int x){
    int n = A.size();
    int lo = -1, hi = n;
    //반복문 불변식 1 : lo < hi
    //반복문 불변식 2 : A[lo] < x <= A[hi]
    
    while(lo + 1 <hi){ //반복문 불변식을 위한 조건1
        int mid = (lo + hi) / 2;	
        if(A[mid] < x)	//불변식 2를 위한 조건2
            lo = mid;
        elsr
            hi = mid;
    }
    return hi;
}
```

불변식을 이용해 반복문의 정당성을 증명하는 과정은 귀납법과 다를 것이 없음.

까다로운 코드를 짤 때 해당 코드가 가져야 할 불변식을 파악하고 작성하면 좀 더 오류가 적은 코드를 작성 하 수 있음.

### 삽입정렬과 반복문 불변식

```C++
void insertionSort(vecotr<int>& A){
    for(int i = 0; i < A.size(); ++i){
        //불변식 : A[0,1,2,...,i-1]은 이미 정렬 되어 있음
        //A[0,1,2,...i-1]에 A[i]를 끼워넣는다
        int j = i;
        while(j > 0 && A[j - 1] > A[j]){
            swap(A[j-1],A[j]);
            --j
        }
    }
}
```

## 5.3 귀류법

귀류법은 대개 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용됨. 선택한 답보다 좋은 답이 있다고 가정한 후에, 사실은 그런 일이 있을 수 없음을 보이면 최선의 답을 선택앴음을 보일 수 있음.

### 책장 쌓기

각 책장마다 버틸 수 있는 최대 무게 Mi과 자신의 무게 Wi가 주어진다면, 이때 책장을 가장 높이 쌓는 다면 몇개나 쌓을 수 있을까?

->above(i)가 i번 책장 위에 쌓인 모든 책장의 집합이라고 할 때 ***무게의 합은 버틸수 있는 무게 이하여야 함.***

- 쌓는 순서를 결정해야 함

Wi로 정렬해서 가장 무거운 책장일수록 아래에? Mi로 정렬해 가장튼튼한 책장을 아래에?

-> Mi + Wi 가 큰 것부터 아래에 놓아야 함

귀류법 사용을 이용한 증명

- 귀류법을 쓰기 위해서는 우리가 믕명하려는 사실의 반대를 가정해야 함
- 가정 : 어떤 입력의 최적해를 구했는데 Mi + Wi가 더 큰 책장 A가 더 작은 책장 B위에 올라간 형태라고 가정

## 귀류법을 이용한 증명들

- 알고리즘의 결과가 최선(최단 경로를 찾는다거나, 가장 높은 탑을 쌓는다거나)임을 보이기 위해 각 단계에서 최선의 선택을 함을 귀류법으로 증명.
- 각 단계에서 최선의 선택을 한다면 다음 단계에서도 최선의 선택을 할 수 있음을 귀납법으로 증명.

> 내가 할 수 있을까...

## 5.4 다른 기술들

1. 비둘기집의 원리

2.  동전 뒤집기

100개의 동전이 바닥에 깔려 있는데 이 중 F개는 앞면, 100 - F개는 뒷면이 위로 놓여있을때, 모두 앞면을 위로 하게 뒤집고 싶은데 한 번 뒤집을 때 반드시 X개의 동전을 한꺼번에 뒤집어야 함. 답의 상한은?

-> 100번

3. 순환 소수 찾기

분수 a/b가 주어딜 때 실수 연산을 쓰지 않고 이 분수를 소수 형태로 출력하려 함.

```c++
//a >=0, b > 0 이라 가정
void printDecimal(int a, int b){
    int iter = 0;
    while(a > 0){
        if(iter++ == 1) cout << '.';
        cout << a / b;
        a = (a % b) * 10
    }
}
```

무한소수(e.g. 1/11 -> 0.09090909....)가 주어지면 이 함수는 영영 끝나지 않음

-> 무한 소수를 인식해서 별도로 처리해줘야 함.

- 비둘기 집의 원리를 쓰면 이 문제를 쉽게 해결 할 수 있음.

```c++
a % b
```

이 계산 결과는 항상 [0, b - 1] 범위의 값을 가짐. ***while문이 b+1번 반복될 떄까지 함수가 종료하지 않아다면, a % b의 결과는 b가지의 결과만 가질 수 있으니 결과가 중복 되는 경우가 반드시 있겠지요. 그러면 같은 결과가 첫 번째로 등장했을 때부터 두번째 등장할 때까지 무한히 순환되는 순환 소수임을 알 수 있습니다.***

### 구성적 증명(Constructive proof)

구성적 증명은 흔히 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해서 사용됨. 답의 실제 예를 들거나 답을 만드는 방법을 실제로 제시하는 증명.

(e.g.) 하늘을 나는 교통수잔을 만들 수 있는가?

구성적 증명 : 비행기를 직접 만들어서 보여줌 또는 비행기를 만드는 법이 적힌 설명서를 건네 줌.

-> '답이 존재하는가'에 대한 댇바으로 '이렇게 만들면 된다'라고 하는 것이 구성적 증명

### 안정적 결혼 문제

구성적 증명으로 해결되는 대표적 문제. 알고리즘을 제시함으로써 답이 존재함을 보였음

1. 처음에 여성이 가장 선호하는 남성에게 프로포즈, 선택 받지 못하면 돌아감
2. 돌아간 여성들이 다른 선호하는 남성에게 프로포즈, ***남성은 더 마음에 드는 여성이 오면 그 여성을 선택***
3. 더 프로포즈할 여성이 없을때까지 2번을 반복

이 알고리즘이 항상 종료된다는 것을 증명해야 함.

***-> 남성은 여성이 오면 반드시 선택해야한다는 가정 필요***



